# 새로배운 것

map은. 함수를. 반복
a['문자열'] 로 접근
map(함수,반복가능한것)
반복가능한것은 여러개 넣을 수 있으며, 해당요소를 한번에 함수에 넣는다.



매개변수에 기본값을 할당하면, 
해당 인자를 불러오지 않아도 호출해준다 ( 인자를 입력하지 않아 문법오류여도 실행 가능하게 해준다)

인자 변수는 
def 함수 (*arge) 로 작성한다.
(튜플로 저장된다.)

매개인자 변수
def 함수 (**kwargs) 
(딕셔너리로 저장됨

sorted 함수

(문자열,리스트, 튜플 등)
오름차순 (리스트로) 반환 리버스하면 내림차순

range 함수

range(5) 는 출력하면 
range(0,5) 가 나온다 --> 0~4까지
sum(range(5)) = 0~4 까지 더한값 = 10

 pass
조건문에서 특정조건시 아무것도 하지 않겠다? -> 비워두는게 아니라 pass 입력
특정조건시, 밑으로내려가는게 아니라, 해당 조건에서 끝나고, 아무것도 하지 않음

print함수

print함수 매개변수에 end = \n 이라는 기본 매개변수가 들어가져 있다.
따라서 print 함수 여러번 호출 할떄, 줄을 바꾸기 싫으면 해당 인자를 입력하여 값을 바꾸면 된다.
*args 로 되어있어, 프린트 함수 한번에 여러번 출력 하는 것도 가능하다.

빌트인 함수
sum 함수와 같은 빌트인 함수의
sum = 3
과 같이 변수를 선언하면 int형으로 바뀌게 되어
sum() 함수는 불러오지 못하게 된다.

글로벌 영역에 sum이 있기 떄문에 ,그걸 사용하게 되고
빌트인 까지 나가서 찾지 않게 되기 때문이다.

전역변수

전역변수는 global *** 
선언을 하고 그밑으로
이어나가야 한다. 바로 못쓴다.


딕셔너리

딕셔너리를 인자로 함수에 입력할때,
함수의 매개변수가 일반값이면 오류가 난다.
**로 해서 언패킹을 해야한다

패킹/언패킹
언패킹 **붙여서 보내면
키-값 쌍을 꺼내서
키=값 형태의 개별 키워드 인자로 전달함

*의 경우, 리스트 튜플등으로 묶여있는 데이터를
개별 위치 인자로 풀어서 전달함
리스트는 하나의 덩어리(객체로 인식하기에)
풀어서 전달해야 한다.


재귀함수

    if number < 10: 
        return number
    else:
        return (number % 10) + sum_of_digits(number//10)

321입력시
1 + (32) -> 2+ (3) -> 3


empyt list = [] 는
불리언으로 하면 False가 나온다.
빈 리스트 print로 출력하면 []로 나온다.

number_of_people = 0


def increase_user():
    global number_of_people
    number_of_people += 1


def create_user(name, age, address):
    print(f"현재 가입 된 유저 수 : {number_of_people}")
    increase_user()
    user_info = {'name' : name,
                 'age' : age,
                 'address' : address,}
    return print(f"{name} 환영합니다!\n{user_info}")

create_user('홍길동',30,'서울')

(매개변수의 입력값 이름과, 인수의 value 매칭하고 싶으면 locals() 쓰면 된다.)
직접 만들려면 insepct로 이름 감지해서. 해당 이름을 key값에 넣고 반환하면 된다.


map은 계획만 세워두고,
결과를 달라할때 계산한다
(리스트로 형변환 할때 or 반복문 돌릴 때)
효율성을 위해
range(),zip()도 마찬가지이다. (지연평가)

itst =[100억개 ]

100억개 메모리 만들고
for i in list

range(100억)은
메모리1개만 있으면 됨.. 

